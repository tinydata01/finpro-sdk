/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, Input, Output, EventEmitter } from '@angular/core';
import { Subject, Subscription, timer } from 'rxjs';
import { switchMap, take, tap } from 'rxjs/operators';
export class CounterDirective {
    constructor() {
        this._counterSource$ = new Subject();
        this._subscription = Subscription.EMPTY;
        this.interval = 1000;
        this.value = new EventEmitter();
        this._subscription = this._counterSource$.pipe(switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        ({ interval, count }) => timer(0, interval).pipe(take(count), tap((/**
         * @return {?}
         */
        () => this.value.emit(--count))))))).subscribe();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.startTimer();
    }
    /**
     * @return {?}
     */
    startTimer() {
        this._counterSource$.next({ count: this.counter, interval: this.interval });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._subscription.unsubscribe();
    }
}
CounterDirective.decorators = [
    { type: Directive, args: [{
                selector: '[counter]'
            },] }
];
/** @nocollapse */
CounterDirective.ctorParameters = () => [];
CounterDirective.propDecorators = {
    counter: [{ type: Input }],
    value: [{ type: Output }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    CounterDirective.prototype._counterSource$;
    /**
     * @type {?}
     * @private
     */
    CounterDirective.prototype._subscription;
    /** @type {?} */
    CounterDirective.prototype.counter;
    /** @type {?} */
    CounterDirective.prototype.interval;
    /** @type {?} */
    CounterDirective.prototype.value;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZXIuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1vdHAtYm94LyIsInNvdXJjZXMiOlsibGliL2RpcmVjdGl2ZXMvdGltZXIuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUF1QyxNQUFNLGVBQWUsQ0FBQztBQUU1RyxPQUFPLEVBQUUsT0FBTyxFQUFjLFlBQVksRUFBRSxLQUFLLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDaEUsT0FBTyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFLdEQsTUFBTSxPQUFPLGdCQUFnQjtJQVF6QjtRQVBRLG9CQUFlLEdBQUcsSUFBSSxPQUFPLEVBQU8sQ0FBQztRQUNyQyxrQkFBYSxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUM7UUFHM0MsYUFBUSxHQUFXLElBQUksQ0FBQztRQUNkLFVBQUssR0FBRyxJQUFJLFlBQVksRUFBVSxDQUFDO1FBR3pDLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQzFDLFNBQVM7Ozs7UUFBQyxDQUFDLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsQ0FDOUIsS0FBSyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQ25CLElBQUksQ0FBQyxLQUFLLENBQUMsRUFDWCxHQUFHOzs7UUFBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssQ0FBQyxFQUFDLENBQ3RDLEVBQ0osQ0FDSixDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQ2xCLENBQUM7Ozs7O0lBRUQsV0FBVyxDQUFDLE9BQXNCO1FBQzlCLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUN0QixDQUFDOzs7O0lBRU0sVUFBVTtRQUNiLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0lBQ2hGLENBQUM7Ozs7SUFFRCxXQUFXO1FBQ1AsSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNyQyxDQUFDOzs7WUFoQ0osU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxXQUFXO2FBQ3hCOzs7OztzQkFLSSxLQUFLO29CQUVMLE1BQU07Ozs7Ozs7SUFMUCwyQ0FBNkM7Ozs7O0lBQzdDLHlDQUEyQzs7SUFFM0MsbUNBQXlCOztJQUN6QixvQ0FBd0I7O0lBQ3hCLGlDQUE2QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBTdWJqZWN0LCBPYnNlcnZhYmxlLCBTdWJzY3JpcHRpb24sIHRpbWVyIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBzd2l0Y2hNYXAsIHRha2UsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbY291bnRlcl0nXG59KVxuZXhwb3J0IGNsYXNzIENvdW50ZXJEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBfY291bnRlclNvdXJjZSQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xuXG4gICAgQElucHV0KCkgY291bnRlcjogbnVtYmVyO1xuICAgIGludGVydmFsOiBudW1iZXIgPSAxMDAwO1xuICAgIEBPdXRwdXQoKSB2YWx1ZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuX2NvdW50ZXJTb3VyY2UkLnBpcGUoXG4gICAgICAgICAgICBzd2l0Y2hNYXAoKHsgaW50ZXJ2YWwsIGNvdW50IH0pID0+XG4gICAgICAgICAgICAgICAgdGltZXIoMCwgaW50ZXJ2YWwpLnBpcGUoXG4gICAgICAgICAgICAgICAgICAgIHRha2UoY291bnQpLFxuICAgICAgICAgICAgICAgICAgICB0YXAoKCkgPT4gdGhpcy52YWx1ZS5lbWl0KC0tY291bnQpKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgKS5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lcigpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGFydFRpbWVyKCkge1xuICAgICAgICB0aGlzLl9jb3VudGVyU291cmNlJC5uZXh0KHsgY291bnQ6IHRoaXMuY291bnRlciwgaW50ZXJ2YWw6IHRoaXMuaW50ZXJ2YWwgfSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbn0iXX0=